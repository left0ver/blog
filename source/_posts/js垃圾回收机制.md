---
title: javascript的垃圾回收机制
date: 2022-04-21 18:02:38
tags:
 - javascript
---

# js垃圾回收机制

- 在一些语言中，垃圾回收是需要程序员手动回收，如c，c++。但像java，javaScript中的垃圾回收是浏览器自动进行的。

- 在垃圾回收中，对象的可达性就变得尤为关键，对于一些不可达的变量，js引擎会自动将其回收掉，以防止内存泄漏

- 现在大部分的浏览器的引擎都是使用的标记的算法（`mark-and-sweep`）
 
  <!-- more -->

  - #### 算法实现

    js垃圾回收器会定期执行垃圾回收算法

    - 垃圾收集器先找到所有的根，并标记他们
    - 然后遍历并标记来自这些根的引用（这些变量根下面的）
    - 如此往复，直到所有的可达的变量都被访问到

    - 最后未标记的对象被删除，被垃圾回收器回收

    这两句话是什么意思呢,看下面的代码

    ```javascript
    		let obj={
                info:{
                    name:"zwc"
                },
                pwd:"123456"
            }
    ```

    1.首先找到所有的根，这里只有一个根，即obj这个对象，找到他并标记

    2.其次再从遍历这些根，这里找到这个根下面的引用（变量），这里有2个引用，即info，pwd ，并标记他们

    3.因为info是个对象，然后再找到info对象下面的引用，name 并标记他

       ​      **这里的算法有点类似广度优先遍历(`bfs`)**

       

      这里倘若我们执行下面的代码

    ```javascript
    obj.info.name=null
    ```

    则obj.info.name 这个变量就会被回收

    倘若我们执行下面这个代码

    ```javascript
    obj=null
    ```

     则obj这整个对象就都会被回收，这里为什么怎么对象都会被回收呢？

    ​     虽然obj对象里面的引用并没有置为null，但是obj对象置为了null，obj下面的所有变量就变成了`不可达`，因为obj下面的变量只能通过obj来访问，现在obj为null，obj已经不可达了，自然下面的引用也是不可达，因此整个对象就被回收掉了 

    - 对于Map,Set这两个个数据结构来说,它的垃圾回收和其他的数据结构有点不一样

       当你执行了下面这一段代码

    ```javascript
     const map= new Map()
     map.set("name",1)
     map.set("name2",4)
     map.set("name3",5)
     map.get("name")=null
    ```

    现在你可以猜测一下map里的"name" 这个key 有没有被回收掉呢？

    答案是：没有

    理论上来说是要被回收掉的，可是为什么没有被回收掉呢？

    这是因为Map集合的key是强引用，只有执行 map =null 的时候，map集合和它里面的键值<key,value>对才会被回收

    当我们map里面的数据比较多的时候，这样就容易导致内存泄漏

    - 因此推出了weakMap 这个数据结构,Set 集合对应的是weakSet,原理和weakMap一样

    weakMap 是弱引用，当你将里面的某个变量置为null，这时候垃圾回收器就会将其回收，这个key就没了。

    因此WeakMap 只有4个方法（key只能是object类型）

    - `weakMap.get(key)`

    - `weakMap.set(key, value)`

    - `weakMap.delete(key)`

    - `weakMap.has(key)`

      **weakMap不支持迭代，和获取所有key或者value的方法**

      ​      这是因为weakMap是弱引用，当我们将一个key的value置为null时，理论上来说我们是不知道它什么时候被回收的，这取决于引擎的算法的具体设计，有时候cpu比较忙的时候就会晚一点回收，因此weakMap里面的key的数量是不确定的，因此有了上述限制。

    **我们常说要避免全局变量，那么我们为什么要避免全局变量呢？**

    ​        这是因为当你定义了一个全局变量，全局变量是在最顶层，然后垃圾回收器就将这个对象标记为根，然后这个对象就一直存在内存中，除非你自己手动将其置为null，这时候垃圾回收器就会将其回收。

    ​       但很多时候我们程序员经常会忽略掉把一些不要用的变量置为null，这样就容易导致内存泄漏，尤其当项目很大的时候，

    **那为什么局部变量就不会呢？**

    ​       因为当我们在一个函数里面定义了一个局部变量，我们调用完了这个函数之后，这些变量就不存在了，会被垃圾回收器回收，这样就可以较好地避免内存泄漏。

    